<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>操作系统笔记 | 八千里云月</title><meta name="author" content="hlsong"><meta name="copyright" content="hlsong"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="操作系统1 进程管理1.1 进程的描述1.1.1 进程的定义为了使参与并发执行的每个程序（含数据）都能独立地运行，操作系统必须为之配置一个专门的数据结构，称为进程控制块（Process Control Block,PCB）,用于控制和管理进程。这样，由程序段，相关的数据段以及PCB三部分组成进程实体。一般，我们将进程实体称为进程。例如，所谓创建进程，实质上就是创建进程实体中的PCB。 进程是进程实">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统笔记">
<meta property="og:url" content="http://h1song.github.io/2022/11/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="八千里云月">
<meta property="og:description" content="操作系统1 进程管理1.1 进程的描述1.1.1 进程的定义为了使参与并发执行的每个程序（含数据）都能独立地运行，操作系统必须为之配置一个专门的数据结构，称为进程控制块（Process Control Block,PCB）,用于控制和管理进程。这样，由程序段，相关的数据段以及PCB三部分组成进程实体。一般，我们将进程实体称为进程。例如，所谓创建进程，实质上就是创建进程实体中的PCB。 进程是进程实">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s1.ax1x.com/2022/11/30/zwgUpQ.jpg">
<meta property="article:published_time" content="2022-11-29T13:44:26.546Z">
<meta property="article:modified_time" content="2022-11-30T13:08:57.555Z">
<meta property="article:author" content="hlsong">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s1.ax1x.com/2022/11/30/zwgUpQ.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://h1song.github.io/2022/11/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '操作系统笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-11-30 21:08:57'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s1.ax1x.com/2022/11/30/zwgJk8.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s1.ax1x.com/2022/11/30/zwsjoD.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">八千里云月</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">操作系统笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-11-29T13:44:26.546Z" title="发表于 2022-11-29 21:44:26">2022-11-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-11-30T13:08:57.555Z" title="更新于 2022-11-30 21:08:57">2022-11-30</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="操作系统笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="1-进程管理"><a href="#1-进程管理" class="headerlink" title="1 进程管理"></a>1 进程管理</h2><h3 id="1-1-进程的描述"><a href="#1-1-进程的描述" class="headerlink" title="1.1 进程的描述"></a>1.1 进程的描述</h3><h4 id="1-1-1-进程的定义"><a href="#1-1-1-进程的定义" class="headerlink" title="1.1.1 进程的定义"></a>1.1.1 进程的定义</h4><p>为了使参与并发执行的每个程序（含数据）都能独立地运行，操作系统必须为之配置一个专门的数据结构，称为进程控制块（Process Control Block,PCB）,用于控制和管理进程。这样，由程序段，相关的数据段以及PCB三部分组成进程实体。一般，我们将进程实体称为进程。例如，所谓创建进程，实质上就是创建进程实体中的PCB。</p>
<p>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位</p>
<h4 id="1-1-2-进程的特征"><a href="#1-1-2-进程的特征" class="headerlink" title="1.1.2 进程的特征"></a>1.1.2 进程的特征</h4><p>动态性：进程的本质是进程实体的执行过程</p>
<p>并发性：多个进程实体同存于内存中</p>
<p>独立性：指进程实体是一个能独立运行，独立获得资源和独立接受调度的单位</p>
<p>异步性：进程之间是按照异步方式运行的，各自独立</p>
<h4 id="1-1-3-进程的基本状态及转换"><a href="#1-1-3-进程的基本状态及转换" class="headerlink" title="1.1.3 进程的基本状态及转换"></a>1.1.3 进程的基本状态及转换</h4><h5 id="进程的三种基本状态"><a href="#进程的三种基本状态" class="headerlink" title="进程的三种基本状态"></a>进程的三种基本状态</h5><p>就绪（ready）：可运行，由于其他进程处于运行状态而暂时停止运行；如果系统中有很多就绪进程，通常它们按照一定的策略排成一个队列，称为<strong>就绪队列</strong></p>
<p>执行（Running）：该时刻进程占用 CPU；单处理机系统中中只有一个进程处于执行状态，多处理机系统中可以有多个进程处于执行状态</p>
<p>阻塞（Block）：该进程正在等待某一事件发生（如等待输入&#x2F;输出操作的完成）而暂时停止运行，这时，即使给它CPU控制权，它也无法运行</p>
<h5 id="三种基本状态的转换"><a href="#三种基本状态的转换" class="headerlink" title="三种基本状态的转换"></a>三种基本状态的转换</h5><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/8-%E8%BF%9B%E7%A8%8B%E4%BA%94%E4%B8%AA%E7%8A%B6%E6%80%81-16697313547966.jpg" alt="8-进程五个状态"></p>
<h5 id="创建状态和终止状态"><a href="#创建状态和终止状态" class="headerlink" title="创建状态和终止状态"></a>创建状态和终止状态</h5><p>创建状态：引入的目的是为了保证进程的调度操作必须在创建工作完成后进行。首先由进程申请一个空白PCB，并在PCB中填写用于控制和管理进程的信息；然后为该进程分配运行所必需的资源；最后将该进程转入就绪状态并插入就绪队列之中。</p>
<p>终止状态：进程的终止要通过两个步骤：等待操作系统进行善后处理，最后将其PCB清零并将PCB空间返回系统。</p>
<p>进入终止状态的情况：到达了自然结束点；出现了无法克服的错误；被操作系统所终结；被其他有终止权的进程终结。</p>
<h5 id="挂起操作和进程状态的转换"><a href="#挂起操作和进程状态的转换" class="headerlink" title="挂起操作和进程状态的转换"></a>挂起操作和进程状态的转换</h5><h6 id="挂起操作"><a href="#挂起操作" class="headerlink" title="挂起操作"></a>挂起操作</h6><p>引入：</p>
<ol>
<li>终端客户的需要：当终端用户发现自己的程序在运行期间发现问题，希望暂停程序的运行</li>
<li>父进程请求：有时父进程希望挂起自己的某个子进程，以便考察和修改该子进程或者协调各子进程间的活动</li>
<li>负荷调节的需要：如果有大量处于阻塞状态的进程，进程可能会占用着物理内存空间，显然不是我们所希望的，毕竟物理内存空间是有限的，被阻塞状态的进程占用着物理内存就一种浪费物理内存的行为。</li>
<li>操作系统的需要：操作系统有时希望挂起某些进程，以便检查运行中的资源使用情况或进行记账</li>
</ol>
<p><strong>描述进程没有占用实际的物理内存空间的情况，这个状态就是挂起状态。</strong></p>
<p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221129221807378.png" alt="image-20221129221807378"></p>
<h4 id="1-1-4进程的控制结构"><a href="#1-1-4进程的控制结构" class="headerlink" title="1.1.4进程的控制结构"></a>1.1.4进程的控制结构</h4><p>为了描述控制进程的运行，系统中存放进程的管理和控制信息的数据结构称为进程控制块（PCB Process Control Block），它是进程实体的一部分，是操作系统中最重要的记录性数据结构。它是进程管理和控制的最重要的数据结构，每一个进程均有一个PCB，在创建进程时，建立PCB，伴随进程运行的全过程，直到进程撤消而撤消。</p>
<h5 id="进程控制块中的信息"><a href="#进程控制块中的信息" class="headerlink" title="进程控制块中的信息"></a>进程控制块中的信息</h5><ul>
<li>进程标识符：（1）外部标识符：为了方便用户对进程的访问，需为每个进程设置一个外部标识符（2）内部标识符。为了方便系统对进程的使用，在OS中又为进程设置了内部标识符。</li>
<li>处理机状态：处理机状态信息也称为处理机的上下文，主要由处理机的各种寄存器中的内容组成的。包括1.通用寄存器 2.指令计数器 3.程序状态PSW（包含状态信息，如条件码，执行方式） 4.用户栈指针，指每个用户进程都有一个或若干个与之相关的系统栈。</li>
<li>进程调度信息:1.进程状态 2.进程优先级 3.进程调度所需的其他信息 ，与采用的进程调度算法有关 4.事件，指进程由执行状态转变为阻塞状态所等待发生的事件</li>
<li>进程控制信息：1.程序和数据的地址 2.进程同步和通信机制，如消息队列指针和信息量 3.资源清单 4.链接指针，指本进程PCB所在队列的下一个PCB的首地址。</li>
</ul>
<h5 id="进程控制块的组织方式"><a href="#进程控制块的组织方式" class="headerlink" title="进程控制块的组织方式"></a>进程控制块的组织方式</h5><ol>
<li><p>线性方式：将系统内所有PCB放在一张线性表中，将该表的首地址放在内存的一个专用区域中。优点：实现简单，开销小 缺点:每次查找时需要扫描整张表</p>
</li>
<li><p>链接方式：把具有相同进程状态的PCB分别通过PCB中的链接字链接成一个队列，形成就绪队列，阻塞队列，空白队列等</p>
<p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/IMG_20221024_202532.jpg" alt="IMG_20221024_202532"></p>
</li>
<li><p>索引方式：系统根据所有进程状态的不同建立几张索引表，将各索引表在内存的首地址记录在内存的一些专用单元中。索引表的表目中记录具有相应状态的某个PCB在PCB表中的位置。</p>
</li>
</ol>
<p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/IMG_20221024_202553.jpg" alt="IMG_20221024_202553"></p>
<h3 id="1-2-进程控制"><a href="#1-2-进程控制" class="headerlink" title="1.2 进程控制"></a>1.2 进程控制</h3><h4 id="1-2-1-操作系统内核"><a href="#1-2-1-操作系统内核" class="headerlink" title="1.2.1 操作系统内核"></a>1.2.1 操作系统内核</h4><h4 id="1-2-2-进程的创建"><a href="#1-2-2-进程的创建" class="headerlink" title="1.2.2 进程的创建"></a>1.2.2 进程的创建</h4><h4 id="1-2-3-进程的阻塞与唤醒"><a href="#1-2-3-进程的阻塞与唤醒" class="headerlink" title="1.2.3 进程的阻塞与唤醒"></a>1.2.3 进程的阻塞与唤醒</h4><h4 id="1-2-4-进程的上下文切换"><a href="#1-2-4-进程的上下文切换" class="headerlink" title="1.2.4 进程的上下文切换"></a>1.2.4 进程的上下文切换</h4><h3 id="1-3-进程同步"><a href="#1-3-进程同步" class="headerlink" title="1.3 进程同步"></a>1.3 进程同步</h3><h4 id="1-3-1-进程同步的基本概念"><a href="#1-3-1-进程同步的基本概念" class="headerlink" title="1.3.1 进程同步的基本概念"></a>1.3.1 进程同步的基本概念</h4><h5 id="进程同步问题的产生："><a href="#进程同步问题的产生：" class="headerlink" title="进程同步问题的产生："></a>进程同步问题的产生：</h5><p>在多道程序的环境中，系统中的多个进程可以并发执行， 同时它们又要共享系统中的资源，这些资源有些是可共享 使用的，如磁盘，有些是以独占方式使用的，如打印机。 由此将会产生错综复杂的进程间相互制约的关系。 </p>
<h5 id="两种形式的制约关系："><a href="#两种形式的制约关系：" class="headerlink" title="两种形式的制约关系："></a>两种形式的制约关系：</h5><ul>
<li>间接相互制约关系：共享某种系统资源。</li>
<li>直接相互制约关系：主要源于进程间合作。</li>
</ul>
<h5 id="临界资源"><a href="#临界资源" class="headerlink" title="临界资源"></a>临界资源</h5><p>互斥共享的资源：临界资源 虽然计算机系统中多个进程可以共享 系统中的各种资源，然而有些资源一 次只能为一个进程使用。 一次仅能为一个进程所使用的资源称 为临界资源。 </p>
<p>临界资源实例 ：硬件资源：打印机； 软件资源：内存变量、指针、数组。</p>
<h5 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h5><p>不论是硬件临界资源还是软件临界资源，多个进程必须互斥地对它进行访问。每个进程访问临界资源的那段代码被称为<strong>临界区</strong>（critical section）。</p>
<p>进入区：每个进程在进入临界区之前，需要对欲访问的临界资源进行检查，看它是否正在被访问。进行这项检查的代码被称为进入区</p>
<p>退出区：用于将临界区正被访问的标志恢复为未被访问的标志</p>
<p>剩余区：除进入区，临界区，退出区之外的所有代码</p>
<p>可把一个访问临界资源的循环进程描述如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>（TURE）</span><br><span class="line">&#123;</span><br><span class="line">	进入区</span><br><span class="line">	临界区</span><br><span class="line">	退出区</span><br><span class="line">	剩余区</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="同步机制应遵循的规则"><a href="#同步机制应遵循的规则" class="headerlink" title="同步机制应遵循的规则"></a>同步机制应遵循的规则</h5><ol>
<li>空闲让进：当无进程处于临界区时，表明临界资源处于空闲状态，应允许一个请求进入临界区的进程立刻进入自己的临界区</li>
<li>忙则等待：当有进程进入临界区时，表示临界资源正在被访问，其它试图进入临界区的资源必须等待，保证对资源的互斥访问</li>
<li>有限等待：对要求访问临界资源的进程，应保证在有限时间内能进入自己的临界区，以免陷入“死等”状态</li>
<li>让权等待：当进程不能进入自己的临界区时，应立即释放处理机，以免进程陷入“忙等”状态</li>
</ol>
<h4 id="1-3-2-实现进程同步的早期方法"><a href="#1-3-2-实现进程同步的早期方法" class="headerlink" title="1.3.2 实现进程同步的早期方法"></a>1.3.2 实现进程同步的早期方法</h4><h5 id="软件解法"><a href="#软件解法" class="headerlink" title="软件解法"></a>软件解法</h5><p><strong>软件解法1：按需访问</strong></p>
<p>违背忙则等待，让权等待，有限等待</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">VAR busy:boolean := <span class="literal">false</span> ;</span><br><span class="line">Program P1:</span><br><span class="line">	Begin</span><br><span class="line">		repeat </span><br><span class="line">			<span class="title function_">while</span><span class="params">( busy )</span> ;</span><br><span class="line">			busy := <span class="literal">true</span> ; </span><br><span class="line">			critical section ;</span><br><span class="line">			busy := <span class="literal">false</span> ;</span><br><span class="line">			remainder section ;</span><br><span class="line">			until <span class="literal">false</span></span><br><span class="line">	End</span><br><span class="line">Program P2:</span><br><span class="line">	Begin</span><br><span class="line">		repeat </span><br><span class="line">			<span class="title function_">while</span><span class="params">( busy )</span> ;</span><br><span class="line">			busy := <span class="literal">true</span> ; </span><br><span class="line">			critical section ;</span><br><span class="line">			busy := <span class="literal">false</span> ;</span><br><span class="line">			remainder section ;</span><br><span class="line">			until <span class="literal">false</span></span><br><span class="line">End</span><br></pre></td></tr></table></figure>



<p><strong>软件解法2：轮询</strong></p>
<p>轮流访问临界资源，但严格限制资源访问顺序，违背让权等待和有限等待</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">VAR turn:integer := <span class="number">1</span> ;</span><br><span class="line">Program P1:</span><br><span class="line">	Begin</span><br><span class="line">		repeat </span><br><span class="line">		<span class="title function_">while</span><span class="params">( turn = <span class="number">2</span>)</span> ;</span><br><span class="line">		critical section ;</span><br><span class="line">		turn := <span class="number">2</span> ;</span><br><span class="line">		remainder section ;</span><br><span class="line">		until <span class="literal">false</span></span><br><span class="line">	End</span><br><span class="line">Program P2:</span><br><span class="line">	Begin</span><br><span class="line">		repeat </span><br><span class="line">		<span class="title function_">while</span><span class="params">( turn = <span class="number">1</span> )</span> ;</span><br><span class="line">			critical section ;</span><br><span class="line">		turn := <span class="number">1</span> ;</span><br><span class="line">			remainder section ;</span><br><span class="line">		until <span class="literal">false</span></span><br><span class="line">End</span><br></pre></td></tr></table></figure>



<p><strong>软件解法3：访前先看</strong></p>
<p>违背空闲让进，让权等待，有限等待</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">VAR pturn,qturn:boolean := <span class="literal">false</span>,<span class="literal">false</span> ;</span><br><span class="line">Program P:</span><br><span class="line">	Begin</span><br><span class="line">		repeat </span><br><span class="line">		pturn := <span class="literal">true</span> ; </span><br><span class="line">		<span class="keyword">while</span>( qturn ) ;#如果Q进程正在使用则进入等待</span><br><span class="line">		critical section ;</span><br><span class="line">		pturn := <span class="literal">false</span> ;</span><br><span class="line">		remainder section ;</span><br><span class="line">		until <span class="literal">false</span></span><br><span class="line">	End</span><br><span class="line">Program Q:</span><br><span class="line">	Begin</span><br><span class="line">		repeat </span><br><span class="line">		qturn := <span class="literal">true</span> ; </span><br><span class="line">		<span class="keyword">while</span>( pturn ) ;#如果P进程正在使用则进入等待</span><br><span class="line">		critical section ;</span><br><span class="line">		qturn := <span class="literal">false</span> ;</span><br><span class="line">		remainder section ;</span><br><span class="line">	until <span class="literal">false</span></span><br><span class="line">End</span><br></pre></td></tr></table></figure>

<p>软件解法4：Peterson算法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> flag[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> turn;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">   flag[<span class="number">0</span>] = flag[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// 1-&gt;thread wants to grab lock</span></span><br><span class="line">   turn = <span class="number">0</span>; <span class="comment">// whose turn? (thread 0 or 1?)</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">	 flag[self] = <span class="number">1</span>; <span class="comment">// self: thread ID of caller</span></span><br><span class="line">   turn = <span class="number">1</span> - self; <span class="comment">// make it other thread&#x27;s turn</span></span><br><span class="line">   <span class="keyword">while</span> ((flag[<span class="number">1</span>-self] == <span class="number">1</span>) &amp;&amp; (turn == <span class="number">1</span> - self))</span><br><span class="line">      ; <span class="comment">// spin-wait</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">	 flag[self] = <span class="number">0</span>; <span class="comment">// simply undo your intent</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>flag[self] &#x3D; 1 ：设置自己进程感兴趣，想要访问临界区。</p>
<p>turn &#x3D; 1 - self：将turn设置为对方进程。注意这个turn是个共享变量，若多进程&#x2F;多线程进行访问，会保留最后一次写的turn值，前面写的值被写覆盖了(overwriting)。然后是一个自旋等待(CPU空转，忙等待，busy wait)：while ((flag[1-self] &#x3D;&#x3D; 1) &amp;&amp; (turn &#x3D;&#x3D; 1 - self));</p>
<h5 id="硬件解法"><a href="#硬件解法" class="headerlink" title="硬件解法"></a>硬件解法</h5><h6 id="利用SWAP指令实现进程互斥"><a href="#利用SWAP指令实现进程互斥" class="headerlink" title="利用SWAP指令实现进程互斥"></a>利用SWAP指令实现进程互斥</h6><p>不符合让权等待原则</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 交换锁lock和key的值</span></span><br><span class="line">function <span class="title function_">SWAP</span><span class="params">(lock, key )</span> &#123; </span><br><span class="line">	var tmp : boolean := lock ;</span><br><span class="line">	lock := key ;</span><br><span class="line">	key := tmp ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function <span class="title function_">enter_region</span><span class="params">( var lock : boolean )</span> </span><br><span class="line">	Var key:boolean ; <span class="comment">//局部变量</span></span><br><span class="line">	Begin </span><br><span class="line">		key := <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">while</span>(key)</span><br><span class="line">			SWAP(lock,key);</span><br><span class="line">	end</span><br><span class="line">function <span class="title function_">leave_region</span><span class="params">( var lock : boolean )</span> </span><br><span class="line">	Begin </span><br><span class="line">		lock := <span class="literal">false</span>;</span><br><span class="line">	end</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">VAR lock :boolean := <span class="literal">false</span> ;</span><br><span class="line">	Program P1:</span><br><span class="line">		Begin</span><br><span class="line">		repeat </span><br><span class="line">			<span class="title function_">enter_region</span><span class="params">(lock )</span>; </span><br><span class="line">			critical section ;</span><br><span class="line">                	 leave_region(lock); </span><br><span class="line">			remainder section ;</span><br><span class="line">		until <span class="literal">false</span></span><br><span class="line">		End</span><br><span class="line">	Program P2:</span><br><span class="line">	Begin</span><br><span class="line">		repeat </span><br><span class="line">		<span class="title function_">enter_region</span><span class="params">(lock)</span>; </span><br><span class="line">		critical section ;</span><br><span class="line">		leave_region(lock); </span><br><span class="line">		remainder section ;</span><br><span class="line">		until <span class="literal">false</span></span><br><span class="line">	End</span><br></pre></td></tr></table></figure>



<h5 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h5><p>1965年，由荷兰学者Dijkstra提出的信号量机制是一种卓有成效的进程同步工具。</p>
<h6 id="整数型信号量"><a href="#整数型信号量" class="headerlink" title="整数型信号量"></a>整数型信号量</h6><p>定义为一个用于表示资源数目的整型量S，只具有两个原子操作：wait（S）&#x2F;signal（S）这两个操作一直分别被称为P，V操作	</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wait（S）&#123;</span><br><span class="line">	<span class="keyword">while</span>(S&lt;=<span class="number">0</span>) <span class="keyword">do</span> no-pe();</span><br><span class="line">	S--;</span><br><span class="line">&#125;</span><br><span class="line">signal(S)&#123;</span><br><span class="line">	S++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h6><p>整型信号量的wait（S）操作，只要信号量S&lt;&#x3D;0，就会不断的进行测试，不符合让权等待的原则。	</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type semaphore = record </span><br><span class="line">	value: integer ; <span class="comment">// 资源数量</span></span><br><span class="line">	L: <span class="built_in">list</span> of process ; <span class="comment">// 阻塞进程队列</span></span><br><span class="line">end </span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function <span class="title function_">wait</span> <span class="params">( var S ：Semaphore )</span> </span><br><span class="line">	Begin </span><br><span class="line">		S.value := S.value<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">if</span> ( S.value &lt; <span class="number">0</span> ) then <span class="title function_">block</span> <span class="params">(S.L)</span>;</span><br><span class="line">	end</span><br><span class="line">function <span class="title function_">signal</span><span class="params">(var S ：Semaphore )</span> </span><br><span class="line">	Begin </span><br><span class="line">		S.value := S.value+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> ( S.value &lt;= <span class="number">0</span> ) then <span class="title function_">wakeup</span> <span class="params">(S.L)</span>;</span><br><span class="line">	end</span><br></pre></td></tr></table></figure>

<ul>
<li>​	对信号量的每次wait操作，意味着进程请求一个单位的该类 资源，因此描述为S.value:&#x3D; S.value-1；当S.value＜0时，表 示该类资源已分配完毕，因此进程应进行自我阻塞，放弃处 理机，并插入到信号量链表S.L中。 </li>
<li><pre><code>对信号量的每次signal操作，表示执行进程释放一个单位资 源，故S.value:= s.value+1操作表示资源数目加1。若加1后仍 是S.value＜=0，则表示在该信号量链表中，仍有等待该资 源的进程被阻塞，将S.L链表中的第一个等待进程唤醒。
</code></pre>
</li>
</ul>
<h5 id="信号量的应用"><a href="#信号量的应用" class="headerlink" title="信号量的应用"></a>信号量的应用</h5><h6 id="信号量用于进程互斥"><a href="#信号量用于进程互斥" class="headerlink" title="信号量用于进程互斥"></a>信号量用于进程互斥</h6><p>​		为使多个进程能互斥地访问某临界资源，只需为该临界资源设置一个互斥信号量mutex，并设置其初始值为1，然后将各进程访问该资源的临界区CS置于wait（mutex）和signal（mutex）操作之间即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mutex: semaphore :=<span class="number">1</span> ; </span><br><span class="line">Process P1 :</span><br><span class="line">	Begin</span><br><span class="line">	<span class="title function_">while</span> <span class="params">( TRUE )</span></span><br><span class="line">	<span class="title function_">wait</span><span class="params">( mutex )</span> ; </span><br><span class="line">	临界区；</span><br><span class="line">	signal(mutex ) ; </span><br><span class="line">	剩余区</span><br><span class="line">	End</span><br><span class="line">Process P2 :</span><br><span class="line">	Begin</span><br><span class="line">	<span class="title function_">while</span> <span class="params">( TRUE )</span> </span><br><span class="line">	<span class="title function_">wait</span><span class="params">( mutex )</span> ; </span><br><span class="line">	临界区；</span><br><span class="line">	signal(mutex ) ; </span><br><span class="line">	剩余区；</span><br><span class="line">	End</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="信号量用于进程同步"><a href="#信号量用于进程同步" class="headerlink" title="信号量用于进程同步"></a>信号量用于进程同步</h6><p>​		举例说明：</p>
<p>​	1.PI,PO两进程共享缓冲区B,PI负责读入数据并保存在B中， PO负责打印B中数据，要求每个数据必须且只打印一次，不许漏打或重复打印。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Parbegin</span><br><span class="line">VAR S1,S2 : semaphore := <span class="number">1</span>, <span class="number">0</span> ;</span><br><span class="line">Process PI :</span><br><span class="line">	Begin</span><br><span class="line">		repeat</span><br><span class="line">			read x from I/O ;</span><br><span class="line">			wait( S1 ) ; </span><br><span class="line">			B := x ;</span><br><span class="line">			signal(S2 ) ; </span><br><span class="line">		until <span class="literal">false</span></span><br><span class="line">	End</span><br><span class="line">Process PO :</span><br><span class="line">	Begin</span><br><span class="line">		repeat </span><br><span class="line">			<span class="title function_">wait</span><span class="params">( S2 )</span> ; </span><br><span class="line">			y := B ;</span><br><span class="line">			signal(S1 ) ; </span><br><span class="line">			print( y) ;</span><br><span class="line">		until <span class="literal">false</span></span><br><span class="line">	End</span><br><span class="line">Parend</span><br></pre></td></tr></table></figure>

<p>设置两个信号量S1和S2，S1表示缓冲区的空闲区域大小，S2表示缓冲区数据大小。</p>
<p>​	2.PI,PE,PO三进程通过共享缓冲区B协作,PI负责产生随机数 并保存在B中，当B中数据为奇数时由PO负责打印，当B中数 据为偶数时由PE负责打印，要求每个数据必须且只打印一次， 不许漏打或重复打印。请用信号量进行同步。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Parbegin</span><br><span class="line">var S,SO,SE:semaphore :=<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>;</span><br><span class="line">Process PI :</span><br><span class="line">	Begin</span><br><span class="line">		repeat</span><br><span class="line">			generate x randomly;</span><br><span class="line">			wait(S); </span><br><span class="line">			B := x ;</span><br><span class="line">			<span class="keyword">if</span> ( x is odd ) signal( SO ); </span><br><span class="line">			<span class="keyword">else</span> signal( SE ) ; </span><br><span class="line">		until <span class="literal">false</span></span><br><span class="line">	end</span><br><span class="line">Process PE :</span><br><span class="line">	Begin</span><br><span class="line">		repeat </span><br><span class="line">			<span class="title function_">wait</span><span class="params">(SE)</span>;</span><br><span class="line">			y := B ;</span><br><span class="line">			signal( S );</span><br><span class="line">			print( y) ;</span><br><span class="line">		until <span class="literal">false</span>	</span><br><span class="line">	End	</span><br><span class="line">Process PO :</span><br><span class="line">	Begin</span><br><span class="line">		repeat </span><br><span class="line">			<span class="title function_">wait</span><span class="params">(SO)</span>;</span><br><span class="line">			z := B ;</span><br><span class="line">			signal( S );</span><br><span class="line">			print( z) ;</span><br><span class="line">		until <span class="literal">false</span></span><br><span class="line">	End</span><br><span class="line">Parend</span><br></pre></td></tr></table></figure>

<p>设置了三个信号量S,SO,SE，分别表示缓冲区空闲区域大小，缓冲区奇数数目，缓冲区偶数数目</p>
<h5 id="管程机制"><a href="#管程机制" class="headerlink" title="管程机制"></a>管程机制</h5><h4 id="1-3-3-经典进程同步问题"><a href="#1-3-3-经典进程同步问题" class="headerlink" title="1.3.3 经典进程同步问题"></a>1.3.3 经典进程同步问题</h4><h5 id="生产者—消费者问题"><a href="#生产者—消费者问题" class="headerlink" title="生产者—消费者问题"></a>生产者—消费者问题</h5><p>​	多个生产者，多个消费者通过共享含n个缓冲区的缓冲区buffer协作。其中生产者负责生产数据并投入缓冲池，消费者从缓冲池中取数据消费，生产者和消费者，每次生产&#x2F;消费一个数据，要求每个数据必须且只被消费一次。缓冲区为临界资源。任何时刻，<strong>只能有一个</strong>生产者或消费者可以访问缓冲区。</p>
<p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221021083808366-166973170450911.png" alt="image-20221021083808366"></p>
<p>假设公共缓冲池中有n个缓冲区，mutex表示互斥信号量，empty和full分别表示缓冲池中空缓冲区和满缓冲区的数目，又假定这些生产者和消费者相互等效。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> in = <span class="number">0</span>, out = <span class="number">0</span>;</span><br><span class="line">item buffer[n];</span><br><span class="line">semaphore mutex = <span class="number">1</span>, empty = n, full = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">procuder</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">      procuder an item nextp;</span><br><span class="line">      ...</span><br><span class="line">      wait(empty);</span><br><span class="line">      wait(mutex);</span><br><span class="line">      buffer[in] = nextp;</span><br><span class="line">      in = (in+<span class="number">1</span>) % n;</span><br><span class="line">      signal(mutex);</span><br><span class="line">      signal(full);</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">consumer</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">do</span> &#123;</span><br><span class="line">       wait(full);<span class="comment">//判断是否有满缓冲区，满缓冲区-1</span></span><br><span class="line">       wait(mutex);</span><br><span class="line">       nextc = buffer[out];</span><br><span class="line">       out = (out+<span class="number">1</span>) % n;</span><br><span class="line">       signal(mutex);</span><br><span class="line">       siganl(empty);<span class="comment">//空缓冲区+1</span></span><br><span class="line">       consumer the item in nextc;</span><br><span class="line">       ....</span><br><span class="line">   &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  cobegin</span><br><span class="line">    <span class="title function_">producer</span><span class="params">()</span>; consumer();</span><br><span class="line">  coend</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>​	有界缓冲区–》循环缓冲区</p>
<h5 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h5><p>五个哲学者大哥围着一个圆桌吃面，圆桌上有五碗面和五只筷子，他们的生活方式是交替地进行思考和进餐。平时，一个哲学家进行思考，饿了就试图取其左右两只最靠近他的筷子，只有他拿到两只筷子才会就餐，进餐完毕后放下筷子继续思考。</p>
<p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221129213858965.png" alt="image-20221129213858965"></p>
<p>下列代码非常直白</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">PI</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="comment">//哲学家想进餐时，先拿左边的筷子，再拿右边</span></span><br><span class="line">		wait(chopstick[i]);</span><br><span class="line">		wait(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">		...吃饭...</span><br><span class="line">		<span class="comment">//哲学家进餐完成后，先放下左边的筷子，再放下右边</span></span><br><span class="line">		signal(chopstick[i]);</span><br><span class="line">		signal(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果每个哲学家同时拿起自己左边的筷子，就会等待右边的筷子，但右边的筷子已经被其他哲学家使用，这样就会陷入“死等”状态。</p>
<p>如何解决这个问题呢？</p>
<p>方法一：至多只允许有4位哲学家同时去拿左边的筷子，最终能保证至少有以为哲学家能进餐，并在用完后释放他用过的两只筷子，从而是更多的哲学家能够进餐。可以设置count信号量，初始值为4，只允许4位哲学家，保证至少有1位哲学家能进餐。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">semaphore count=<span class="number">4</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">PI</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="comment">//哲学家想进餐时，先拿左边的筷子，再拿右边</span></span><br><span class="line">		wait(count);</span><br><span class="line">		wait(chopstick[i]);</span><br><span class="line">		wait(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">		...吃饭...</span><br><span class="line">		<span class="comment">//哲学家进餐完成后，先放下左边的筷子，再放下右边</span></span><br><span class="line">		signal(chopstick[i]);</span><br><span class="line">		signal(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">		signal(count);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>方法二：仅仅当哲学家的左右两只筷子均可用时，才允许他拿起筷子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">semaphore mutex <span class="number">1</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">PI</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="comment">//哲学家想进餐时，先拿左边的筷子，再拿右边</span></span><br><span class="line">		wait(mutex);</span><br><span class="line">		wait(chopstick[i]);</span><br><span class="line">		wait(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">		signal(mutex);</span><br><span class="line">		...吃饭...</span><br><span class="line">		<span class="comment">//哲学家进餐完成后，先放下左边的筷子，再放下右边</span></span><br><span class="line">		signal(chopstick[i]);</span><br><span class="line">		signal(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>方法三：要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家刚好相反。用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一只筷子，另一个会直接阻塞。这就避免了占有一支后再等待另一只的情况。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">PI</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">0</span>) &#123; <span class="comment">//偶数哲学家，先拿右边的筷子，再拿左边</span></span><br><span class="line">			wait(chopstick[(i + <span class="number">1</span>)%<span class="number">5</span>]) ;</span><br><span class="line">			wait(chopstick[i]) ;</span><br><span class="line">			...吃饭...</span><br><span class="line">			signal(chopstick[(i + <span class="number">1</span>)%<span class="number">5</span>]) ;</span><br><span class="line">			signal(chopstick[i]) ;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; <span class="comment">//奇数哲学家，先拿左边的筷子，再拿右边</span></span><br><span class="line">			wait(chopstick[i]) ;</span><br><span class="line">			wait(chopstick[(i + <span class="number">1</span>)%<span class="number">5</span>]) ;</span><br><span class="line">			...吃饭...</span><br><span class="line">			signal(chopstick[i]) ;</span><br><span class="line">			signal(chopstick[(i + <span class="number">1</span>)%<span class="number">5</span>]) ;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h5><ul>
<li>「读-读」允许：同一时刻，允许多个读者同时读</li>
<li>「读-写」互斥：没有写者时读者才能读，没有读者时写者才能写</li>
<li>「写-写」互斥：没有其他写者时，写者才能写</li>
</ul>
<p>这个问题分为读者优先还是写者优先两种情况</p>
<h6 id="读者优先"><a href="#读者优先" class="headerlink" title="读者优先"></a>读者优先</h6><p>1.初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">semaphore wmutex=<span class="number">1</span>;<span class="comment">//实现对文件的互斥访问，表示当前是否有进程在访问共享文件</span></span><br><span class="line"><span class="type">int</span> readcount=<span class="number">0</span>;<span class="comment">//记录当前有多少个读进程在访问文件</span></span><br><span class="line">semaphore rmutex;<span class="comment">//用于保证对readcount变量的互斥访问</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.写者</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">writer()&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		P(wmutex);<span class="comment">//写之前加锁</span></span><br><span class="line">		write();</span><br><span class="line">		V(wmutex);<span class="comment">//写之后解锁</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.读者</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">reader()&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		P(rmutex);<span class="comment">//各读进程互斥访问readcount</span></span><br><span class="line">		readcount++;<span class="comment">//访问文件读进程数+1</span></span><br><span class="line">		<span class="keyword">if</span>(readcount==<span class="number">1</span>)</span><br><span class="line">			P(wmutex);<span class="comment">//写进程加锁，不允许在读操作过程中执行写操作</span></span><br><span class="line">		V(rmutex);</span><br><span class="line">		read();<span class="comment">//上面这一部分使得多个读者能够同时访问</span></span><br><span class="line">		P(rmutex);<span class="comment">//各读进程互斥访问raeadcount</span></span><br><span class="line">		readcount--;<span class="comment">//每当一个读进程完成读操作，读者数量-1</span></span><br><span class="line">		<span class="keyword">if</span>(readcount==<span class="number">0</span>)</span><br><span class="line">			V(wmutex);<span class="comment">//当没有读者，读操作结束后，写进程解锁</span></span><br><span class="line">		V(rmutex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h6 id="写者优先"><a href="#写者优先" class="headerlink" title="写者优先"></a>写者优先</h6><p>1.初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> readcount=<span class="number">0</span>;<span class="comment">//记录当前有多少个读进程在访问文件</span></span><br><span class="line"><span class="type">int</span> writecount=<span class="number">0</span>;<span class="comment">//当writecount=0,唤醒读者</span></span><br><span class="line">semaphore mutex1;<span class="comment">//用于保证对readcount变量的互斥访问</span></span><br><span class="line">semaphore mutex2;<span class="comment">//用于保证对writecount变量的互斥访问</span></span><br><span class="line"></span><br><span class="line">semaphore mutex;<span class="comment">//用于保证写者之间的互斥访问，其他读者要进入rmutex之前需要在mutex上排队</span></span><br><span class="line">semaphore rmutex=<span class="number">1</span>;<span class="comment">//当有新写者来时，停止所有的读进程。</span></span><br><span class="line">semaphore wmutex=<span class="number">1</span>;<span class="comment">//实现对写操作地互斥访问</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.读者</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">reader()&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		P(mutex);<span class="comment">//实现写者优先访问，禁止读者在rmutex排队,保证一次只有一个读者进程访问rmutex</span></span><br><span class="line">			P(rmutex);<span class="comment">//读者进程加锁</span></span><br><span class="line">				P(mutex1);<span class="comment">//互斥修改readcount变量</span></span><br><span class="line">					readcount++;</span><br><span class="line">					<span class="keyword">if</span>(readcount==<span class="number">1</span>)</span><br><span class="line">						P(wmutex);<span class="comment">//当有读者进程执行读操作时，对写者进程加锁</span></span><br><span class="line">				V(mutex1);</span><br><span class="line">			V(rmutex);<span class="comment">//读者进程解锁</span></span><br><span class="line">		V(mutex);</span><br><span class="line">			读文件...</span><br><span class="line">		P(mutex1);<span class="comment">//互斥修改readcount变量</span></span><br><span class="line">			readcount--;</span><br><span class="line">			<span class="keyword">if</span>(readcount==<span class="number">0</span>)</span><br><span class="line">				V(wmutex);<span class="comment">//当读者数量为0,解锁写者进程，允许写者进程执行写操作</span></span><br><span class="line">		V(mutex1);</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>3.写者</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">writer()&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		P(mutex2);<span class="comment">//各写者进程互斥访问writecount</span></span><br><span class="line">			writecount++;<span class="comment">//写进程数量+1</span></span><br><span class="line">			<span class="keyword">if</span>(writecount==<span class="number">1</span>)</span><br><span class="line">				P(rmutex);<span class="comment">//有写进程时，对读进程加锁</span></span><br><span class="line">		V(mutex2);</span><br><span class="line">		P(wmutex);<span class="comment">//写之前加锁，保证每次只有一个写者可以进行写操作</span></span><br><span class="line">			写文件...</span><br><span class="line">		V(wmutex);</span><br><span class="line">		P(mutex2);</span><br><span class="line">			writecount--;<span class="comment">//每当有一个写进程完成写操作，写者数量-1</span></span><br><span class="line">			<span class="keyword">if</span>(writecount==<span class="number">0</span>)</span><br><span class="line">				V(rmutex);<span class="comment">//若没有写进程正在执行，解锁读者进程</span></span><br><span class="line">		V(mutex2);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="1-4-进程通信"><a href="#1-4-进程通信" class="headerlink" title="1.4 进程通信"></a>1.4 进程通信</h3><p>进程通信指进程之间的信息交换，其所交换的信息量，少者是一个状态或数值，多者则是成千上万个字节</p>
<h4 id="1-4-1-进程通信的方式"><a href="#1-4-1-进程通信的方式" class="headerlink" title="1.4.1 进程通信的方式"></a>1.4.1 进程通信的方式</h4><h5 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h5><p>基本思想</p>
<p>以<code>linux</code>为例</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ps auxf | grep mysql</span><br></pre></td></tr></table></figure>

<p>上面命令行里的「<code>|</code>」竖线就是一个<strong>管道</strong>，它的功能是将前一个命令（<code>ps auxf</code>）的输出，作为后一个命令（<code>grep mysql</code>）的输入，从这功能描述，可以看出<strong>管道传输数据是单向的</strong>，如果想相互通信，我们需要创建两个管道才行。</p>
<p>同时，我们得知上面这种管道是没有名字，所以「<code>|</code>」表示的管道称为<strong>匿名管道</strong>，用完了就销毁。</p>
<p>管道还有另外一个类型是<strong>命名管道</strong>，也被叫做 <code>FIFO</code>，因为数据是先进先出的传输方式。</p>
<p>在使用命名管道前，先需要通过 <code>mkfifo</code> 命令来创建，并且指定管道名字：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkfifo</span> myPipe</span><br></pre></td></tr></table></figure>

<p><code>myPipe </code>就是这个管道的名称，基于 Linux 一切皆文件的理念，所以管道也是以文件的方式存在，我们可以用 ls 看一下，这个文件的类型是 p，也就是 pipe（管道） 的意思：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -l</span><br><span class="line">prw-r--r--. 1 root    root         0 Jul 17 02:45 myPipe</span><br></pre></td></tr></table></figure>

<p>接下来，我们往 myPipe 这个管道写入数据：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span> &gt; myPipe  // 将数据写进管道</span><br><span class="line">                         // 停住了 ...</span><br></pre></td></tr></table></figure>

<p>你操作了后，你会发现命令执行后就停在这了，这是因为管道里的内容没有被读取，只有当管道里的数据被读完后，命令才可以正常退出。</p>
<p>于是，我们执行另外一个命令来读取这个管道里的数据：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> &lt; myPipe  // 读取管道里的数据</span><br><span class="line">hello</span><br></pre></td></tr></table></figure>

<p>可以看到，管道里的内容被读取出来了，并打印在了终端上，另外一方面，echo 那个命令也正常退出了。</p>
<p>可以看出，<strong>管道这种通信方式效率低，不适合进程间频繁地交换数据</strong>。当然，它的好处，自然就是简单，同时也我们很容易得知管道里的数据已经被另一个进程读取了。</p>
<h6 id="管道创建的原理"><a href="#管道创建的原理" class="headerlink" title="管道创建的原理"></a>管道创建的原理</h6><p>匿名管道的创建，需要通过下面这个系统调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> fd[<span class="number">2</span>])</span></span><br></pre></td></tr></table></figure>

<p>这里表示创建一个匿名管道，并返回了两个描述符，一个是管道的读取端描述符 <code>fd[0]</code>，另一个是管道的写入端描述符 <code>fd[1]</code>。注意，<strong>这个匿名管道是特殊的文件，只存在于内存，不存于文件系统中。</strong></p>
<p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-%E7%AE%A1%E9%81%93-pipe-16669492828883.jpg" alt="5-管道-pipe-16669492828883"></p>
<p><strong>所谓的管道，就是内核里面的一串缓存</strong>。从管道的一段写入的数据，实际上是缓存在内核中的，另一端读取，也就是从内核中读取这段数据。另外，管道传输的数据是无格式的流且大小受限。</p>
<blockquote>
<p>这两个描述符都是在一个进程里面，并没有起到进程间通信的作用，怎么样才能使得管道是跨过两个进程的呢？</p>
</blockquote>
<p>我们可以使用 <code>fork</code> 创建子进程，<strong>创建的子进程会复制父进程的文件描述符</strong>，这样就做到了两个进程各有两个「 <code>fd[0]</code> 与 <code>fd[1]</code>」，两个进程就可以通过各自的 <code>fd </code>写入和读取同一个管道文件实现跨进程通信了。</p>
<p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/6-%E7%AE%A1%E9%81%93-pipe-fork.jpg" alt="6-管道-pipe-fork"></p>
<p>管道只能一端写入，另一端读出，所以上面这种模式容易造成混乱，因为父进程和子进程都可以同时写入，也都可以读出。那么，为了避免这种情况，通常的做法是：</p>
<ul>
<li>父进程关闭读取的 <code>fd[0]</code>，只保留写入的 <code>fd[1]</code>；</li>
<li>子进程关闭写入的 <code>fd[1]</code>，只保留读取的 <code>fd[0]</code>；</li>
</ul>
<p>如果需要双向通信，则需要创建两个管道</p>
<p>到这里，我们仅仅解析了使用管道进行父进程与子进程之间的通信，但是在我们 shell 里面并不是这样的。</p>
<p>在 shell 里面执行 <code>A | B</code>命令的时候，A 进程和 B 进程都是 shell 创建出来的子进程，A 和 B 之间不存在父子关系，它俩的父进程都是 shell。</p>
<p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/8-%E7%AE%A1%E9%81%93-pipe-shell.jpg" alt="8-管道-pipe-shell"></p>
<p>在 shell 里通过「<code>|</code>」匿名管道将多个命令连接在一起，实际上也就是创建了多个子进程，那么在我们编写 shell 脚本时，能使用一个管道搞定的事情，就不要多用一个管道，这样可以减少创建子进程的系统开销。</p>
<p>我们可以得知，<strong>对于匿名管道，它的通信范围是存在父子关系的进程</strong>。因为管道没有实体，也就是没有管道文件，只能通过 fork 来复制父进程 <code>fd</code> 文件描述符，来达到通信的目的。</p>
<p>另外，<strong>对于命名管道，它可以在不相关的进程间也能相互通信</strong>。因为命令管道，提前创建了一个类型为管道的设备文件，在进程里只要使用这个设备文件，就可以相互通信。</p>
<p>不管是匿名管道还是命名管道，进程写入的数据都是缓存在内核中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循<strong>先进先出</strong>原则，不支持 <code>lseek</code> 之类的文件定位操作。</p>
<h5 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h5><p>前面说到管道的通信方式是效率低的，因此管道不适合进程间频繁地交换数据。</p>
<p>对于这个问题，<strong>消息队列</strong>的通信模式就可以解决。比如，A 进程要给 B 进程发送消息，A 进程把数据放在对应的消息队列后就可以正常返回了，B 进程需要的时候再去读取数据就可以了。同理，B 进程要给 A 进程发送消息也是如此。</p>
<p>再来，<strong>消息队列是保存在内核中的消息链表</strong>，在发送数据时，会分成一个一个独立的数据单元，也就是消息体（数据块），消息体是用户自定义的数据类型，消息的发送方和接收方要约定好消息体的数据类型，所以每个消息体都是固定大小的存储块，不像管道是无格式的字节流数据。如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。</p>
<p>消息队列生命周期随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列会一直存在，而前面提到的匿名管道的生命周期，是随进程的创建而建立，随进程的结束而销毁。</p>
<p>消息这种模型，两个进程之间的通信就像平时发邮件一样，你来一封，我回一封，可以频繁沟通了。</p>
<p>但邮件的通信方式存在不足的地方有两点，<strong>一是通信不及时，二是附件也有大小限制</strong>，这同样也是消息队列通信不足的点。</p>
<p><strong>消息队列不适合比较大数据的传输</strong>，因为在内核中每个消息体都有一个最大长度的限制，同时所有队列所包含的全部消息体的总长度也是有上限。在 Linux 内核中，会有两个宏定义 <code>MSGMAX</code> 和 <code>MSGMNB</code>，它们以字节为单位，分别定义了一条消息的最大长度和一个队列的最大长度。</p>
<p><strong>消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销</strong>，因为进程写入数据到内核中的消息队列时，会发生从用户态拷贝数据到内核态的过程，同理另一进程读取内核中的消息数据时，会发生从内核态拷贝数据到用户态的过程。</p>
<h5 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h5><h6 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h6><p>​	消息队列的读取和写入的过程，都会有发生用户态与内核态之间的消息拷贝过程。那<strong>共享内存</strong>的方式，就很好的解决了这一问题。</p>
<p>​	现代操作系统，对于内存管理，采用的是虚拟内存技术，也就是每个进程都有自己独立的虚拟内存空间，不同进程的虚拟内存映射到不同的物理内存中。所以，即使进程 A 和 进程 B 的虚拟地址是一样的，其实访问的是不同的物理内存地址，对于数据的增删查改互不影响。</p>
<p>​	<strong>共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中</strong>。这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去，大大提高了进程间通信的速度。</p>
<blockquote>
<h6 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h6><ol>
<li>​	 进程申请一片内存，拿到内存描述符；</li>
<li>​	 如果已分配过，直接获得内存描述符； </li>
<li>​	 利用内存描述符将内存连接到本进程； </li>
<li>​	 读写</li>
</ol>
</blockquote>
<h5 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h5><p>与信号量完全不一样。之前所说的进程通信的方式是在常规状态下的工作模式，对于异常状态下的进程通信，就要使用<code>信号</code>的方式。</p>
<p>在 Linux 操作系统中， 为了响应各种各样的事件，提供了几十种信号，分别代表不同的意义。我们可以通过 <code>kill -l</code> 命令，查看所有的信号：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">kill</span> -l</span><br><span class="line"> 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP</span><br><span class="line"> 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1</span><br><span class="line">11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM</span><br><span class="line">16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP</span><br><span class="line">21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR</span><br><span class="line">31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1  64) SIGRTMAX</span><br></pre></td></tr></table></figure>

<p>运行在 shell 终端的进程，我们可以通过键盘输入某些组合键的时候，给进程发送信号。例如</p>
<ul>
<li>Ctrl+C 产生 <code>SIGINT</code> 信号，表示终止该进程；</li>
<li>Ctrl+Z 产生 <code>SIGTSTP</code> 信号，表示停止该进程，但还未结束；</li>
</ul>
<p>如果进程在后台运行，可以通过 <code>kill</code> 命令的方式给进程发送信号，但前提需要知道运行中的进程 PID 号，例如：</p>
<ul>
<li>kill -9 1050 ，表示给 PID 为 1050 的进程发送 <code>SIGKILL</code> 信号，用来立即结束该进程；</li>
</ul>
<p>所以，信号事件的来源主要有硬件来源（如键盘 Ctrl+C ）和软件来源（如 kill 命令）。</p>
<p>信号是进程间通信机制中<strong>唯一的异步通信机制</strong>，因为可以在任何时候发送信号给某一进程，一旦有信号产生，我们就有下面这几种，用户进程对信号的处理方式。</p>
<p><strong>1.执行默认操作</strong>。Linux 对每种信号都规定了默认操作，例如，上面列表中的 SIGTERM 信号，就是终止进程的意思。</p>
<p><strong>2.捕捉信号</strong>。我们可以为信号定义一个信号处理函数。当信号发生时，我们就执行相应的信号处理函数。</p>
<p><strong>3.忽略信号</strong>。当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。有两个信号是应用进程无法捕捉和忽略的，即 <code>SIGKILL</code> 和 <code>SEGSTOP</code>，它们用于在任何时候中断或结束某一进程。</p>
<h5 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h5><p>前面提到的管道、消息队列、共享内存、信号量和信号都是在同一台主机上进行进程间通信，那要想<strong>跨网络与不同主机上的进程之间通信，就需要 Socket 通信了。</strong></p>
<p>实际上，Socket 通信不仅可以跨网络与不同主机的进程间通信，还可以在同主机上进程间通信。</p>
<p>具体的实现先空着</p>
<h3 id="1-5-线程"><a href="#1-5-线程" class="headerlink" title="1.5 线程"></a>1.5 线程</h3><h4 id="1-5-1-线程的引入"><a href="#1-5-1-线程的引入" class="headerlink" title="1.5.1 线程的引入"></a>1.5.1 线程的引入</h4><p>在早期的操作系统中都是以进程作为独立运行的基本单位，直到后面，计算机科学家们又提出了更小的能独立运行的基本单位，也就是<strong>线程。</strong>为什么要引入线程呢？原因就是为了提高程序并发执行的程度，改善OS的性能。</p>
<p>我们举个例子，假设你要编写一个视频播放器软件，那么该软件功能的核心模块有三个：</p>
<ul>
<li>从视频文件当中读取数据；</li>
<li>对读取的数据进行解压缩；</li>
<li>把解压缩后的视频数据播放出来；</li>
</ul>
<p>对于单进程的实现方式，我想大家都会是以下这个方式：</p>
<p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/14-%E5%8D%95%E7%BA%BF%E7%A8%8Bmp4%E4%BB%A3%E7%A0%81%E5%AE%9E%E4%BE%8B.jpg" alt="14-单线程mp4代码实例"></p>
<p>对于单进程的这种方式，存在以下问题：</p>
<ul>
<li>播放出来的画面和声音会不连贯，因为当 CPU 能力不够强的时候，<code>Read</code> 的时候可能进程就等在这了，这样就会导致等半天才进行数据解压和播放；</li>
<li>各个函数之间不是并发执行，影响资源的使用效率；</li>
</ul>
<p>那改进成多进程的方式：</p>
<p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/15-%E5%A4%9A%E8%BF%9B%E7%A8%8Bmp4-%E4%BB%A3%E7%A0%81%E5%AE%9E%E4%BE%8B.jpg" alt="15-多进程mp4-代码实例"></p>
<p>对于多进程的这种方式，依然会存在问题：</p>
<ul>
<li>进程之间如何通信，共享数据？</li>
<li>维护进程的系统开销较大，如创建进程时，分配资源、建立 PCB；终止进程时，回收资源、撤销 PCB；进程切换时，保存当前进程的状态信息；</li>
</ul>
<p>那到底如何解决呢？需要有一种新的实体，满足以下特性：</p>
<ul>
<li>实体之间可以并发运行；</li>
<li>实体之间共享相同的地址空间；</li>
</ul>
<p>这个新的实体，就是**线程( Thread)**，线程之间可以并发运行且共享相同的地址空间。</p>
<h4 id="1-5-2-线程的定义"><a href="#1-5-2-线程的定义" class="headerlink" title="1.5.2 线程的定义"></a>1.5.2 线程的定义</h4><p><strong>线程是进程当中的一条执行流程。</strong></p>
<p>同一个进程内多个线程之间可以共享代码段、数据段、打开的文件等资源，但每个线程各自都有一套独立的寄存器和栈，这样可以确保线程的控制流是相对独立的。</p>
<p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/16-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.jpg" alt="16-多线程内存结构"></p>
<ul>
<li>线程有时候称为轻量级进程 </li>
<li>是CPU调度和分派的基本单位</li>
<li>可并发执行 </li>
<li>共享进程资源 </li>
<li>一个进程至少有一个主线程</li>
</ul>
<blockquote>
<p>线程的缺点</p>
</blockquote>
<ul>
<li>当进程中的一个线程崩溃时，会导致其所属进程的所有线程崩溃（这里是针对 C&#x2F;C++ 语言，Java语言中的线程奔溃不会造成进程崩溃</li>
</ul>
<h4 id="1-5-3-线程与进程的比较"><a href="#1-5-3-线程与进程的比较" class="headerlink" title="1.5.3 线程与进程的比较"></a>1.5.3 线程与进程的比较</h4><p>线程与进程的比较如下：</p>
<ul>
<li>进程是资源（包括内存、打开的文件等）分配的单位，线程是 CPU 调度的单位；</li>
<li>进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈；</li>
<li>线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系；</li>
<li>线程能减少并发执行的时间和空间开销；</li>
</ul>
<p>对于，线程相比进程能减少开销，体现在：</p>
<ul>
<li>线程的创建时间比进程快，因为进程在创建的过程中，还需要资源管理信息，比如内存管理信息、文件管理信息，而线程在创建的过程中，不会涉及这些资源管理信息，而是共享它们；</li>
<li>线程的终止时间比进程快，因为线程释放的资源相比进程少很多；</li>
<li>同一个进程内的线程切换比进程切换快，因为线程具有相同的地址空间（虚拟内存共享），这意味着同一个进程的线程都具有同一个页表，那么在切换的时候不需要切换页表。而对于进程之间的切换，切换的时候要把页表给切换掉，而页表的切换过程开销是比较大的；</li>
<li>由于同一进程的各线程间共享内存和文件资源，那么在线程之间数据传递的时候，就不需要经过内核了，这就使得线程之间的数据交互效率更高了；</li>
</ul>
<p>所以，不管是时间效率，还是空间效率线程比进程都要高。</p>
<h4 id="1-5-4-线程的上下文切换"><a href="#1-5-4-线程的上下文切换" class="headerlink" title="1.5.4 线程的上下文切换"></a>1.5.4 线程的上下文切换</h4><p>线程与进程最大的区别在于：<strong>线程是调度的基本单位，而进程则是资源拥有的基本单位</strong>。</p>
<p>所以，所谓操作系统的任务调度，实际上的调度对象是线程，而进程只是给线程提供了虚拟内存、全局变量等资源。</p>
<p>对于线程和进程，我们可以这么理解：</p>
<ul>
<li>当进程只有一个线程时，可以认为进程就等于线程；</li>
<li>当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源，这些资源在上下文切换时是不需要修改的；</li>
</ul>
<p>另外，线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换时也是需要保存的。</p>
<blockquote>
<p>线程上下文切换的是什么？</p>
</blockquote>
<p>这还得看线程是不是属于同一个进程：</p>
<ul>
<li>当两个线程不是属于同一个进程，则切换的过程就跟进程上下文切换一样；</li>
<li><strong>当两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据</strong>；</li>
</ul>
<p>所以，线程的上下文切换相比进程，<strong>开销</strong>要小很多。</p>
<h4 id="1-5-5-线程的实现"><a href="#1-5-5-线程的实现" class="headerlink" title="1.5.5 线程的实现"></a>1.5.5 线程的实现</h4><p>主要有三种线程的实现方式：</p>
<ul>
<li><strong>用户线程（User Thread）</strong>：在用户空间实现的线程，不是由内核管理的线程，是由用户态的线程库来完成线程的管理；</li>
<li><strong>内核线程（Kernel Thread）</strong>：在内核中实现的线程，是由内核管理的线程；</li>
<li><strong>轻量级进程（Lightweight Process）</strong>：在内核中来支持用户线程；</li>
</ul>
<h2 id="2-处理机调度和死锁"><a href="#2-处理机调度和死锁" class="headerlink" title="2 处理机调度和死锁"></a>2 处理机调度和死锁</h2><h3 id="2-1-调度算法"><a href="#2-1-调度算法" class="headerlink" title="2.1 调度算法"></a>2.1 调度算法</h3><h4 id="2-1-1-轮转模型"><a href="#2-1-1-轮转模型" class="headerlink" title="2.1.1 轮转模型"></a>2.1.1 轮转模型</h4><h5 id="彩票调度（导论65）"><a href="#彩票调度（导论65）" class="headerlink" title="彩票调度（导论65）"></a>彩票调度（导论65）</h5><p>基本概念：彩票数表示份额</p>
<p>彩票调度背后有一个非常基本的概念：彩票数(ticket）代表了进程（或用户或其他）占有某个资源的份额。</p>
<p>通过不断定时地抽取彩票，彩票调度从概率上(不是确定的)获取这种份额比例。调度程序抽取中奖彩票，这是0到99之间的一个数，比如进程A拥有0到74共75张彩票，进程B拥有75到99的25张，中奖的彩票就决定了运行A还是B。</p>
<blockquote>
<p>彩票调度最精彩的地方在于利用了随机性</p>
</blockquote>
<h5 id="步长调度（导论69）"><a href="#步长调度（导论69）" class="headerlink" title="步长调度（导论69）"></a>步长调度（导论69）</h5><p>​	虽然随机方式可以使调度程序的实现简单，但偶尔不能产生正确的比例，尤其在运行时间很短的情况下。由此Wald Spurger提出了步长调度，一种确定性的公平分配算法。</p>
<p>​	实现原理：系统中每个工作都有自己的步长，这个值与票数值成反比。假设ABC这三个工作的票数分别是100,50和250，我们通过一个大数分别除以他们的票数来获得每个进程的步长，比如用10000除以这些票数值，得到三个进程的步长分别为100，200和40.每次进程运行后，我们会让他的计数器【称为行程（pass）值增加它的步长，记录它的总体进展。</p>
<p>​	 之后，调度程序会根据使用进程的步长及行程值来确定调度哪个进程。基本思路很简单:当需要进行调度时，选择目前拥有最小行程值得进程，并在运行之后将该进程的行程值增加一个步长。</p>
<h4 id="2-1-2-队列模型"><a href="#2-1-2-队列模型" class="headerlink" title="2.1.2 队列模型"></a>2.1.2 队列模型</h4><h5 id="前后台队列调度"><a href="#前后台队列调度" class="headerlink" title="前后台队列调度"></a>前后台队列调度</h5><ul>
<li>既满足交互性很强的终端用户需求，又能及时满足远程用户提交的作业请求 </li>
<li>前后台采取的调度算法不同 </li>
<li>前台无进程的情况下，才调度后台队列的进程（如何实现？）</li>
</ul>
<p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221031153439132.png" alt="image-20221031153439132"></p>
<h5 id="多级反馈队列调度"><a href="#多级反馈队列调度" class="headerlink" title="多级反馈队列调度"></a>多级反馈队列调度</h5><p>多级反馈队列调度算法的调度机制可描述如下：</p>
<ol>
<li>设置多个就绪队列。在系统中设置多个就绪队列，并为每个队列赋予不同的优先级，第一个队列的优先级最高，第二个次之，以此类推。该算法为不同队列的进程所赋予的执行时间片的大小也各不相同，优先级越高的队列其执行时间片也就越小，例如每一个队列的时间片都比上一级队列时间片长一倍。</li>
</ol>
<p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221031153727392.png" alt="image-20221031153727392"></p>
<ol>
<li>每个队列都采用FCFS算法。当新进程进入内存后，首先将它放在第一队列的末尾，按FCFS原则等待调度。轮到该进程执行时，如果它能够在规定的时间片内完成执行，便可直接撤离系统。否则，如果它未能在该时间片内完成执行，调度程序就将其转入第二队列的末尾等待调度，以此类推。当进程最后被降到第n队列时，在第n队列中便采用RR方式运行。</li>
<li>按队列优先级调度。调度程序首先调用最高优先级队列中的进程运行，只有当第1~（i-1）所有队列中都没有进程时，第i队列中的进程才能够被调用。如果第I队列中的某个进程正在执行的同时，又有新的进程进入更高优先级队列，此时正在执行的进程就应该立刻停止，并且被放回第i队列的末尾</li>
</ol>
<h3 id="2-2-实时调度"><a href="#2-2-实时调度" class="headerlink" title="2.2 实时调度"></a>2.2 实时调度</h3><blockquote>
<p>什么是实时调度？</p>
</blockquote>
<p>由于在实时系统中都存在着若干个实施进程或任务，它们用来反应或控制某个（些）外部事件，往往带有某种程度的紧迫性，因而对实时系统中的调度提出了某些特殊要求，前面所介绍的多种调度算法，并不能很好的满足实时系统对调度的要求，为此，需要引入一种新的调度，即实时调度。</p>
<p><strong>HRT: (Hard Real-time)</strong><br><strong>硬实时操作系统</strong>必须使任务在确定的时间内完成。（必须确保堆截止时间的要求）。</p>
<p><strong>SRT: (Soft Real-time)</strong><br><strong>软实时操作系统</strong>能让绝大多数任务在确定时间内完成。（基本能保证对截止时间的要求）。</p>
<h4 id="实现实时调度的基本条件"><a href="#实现实时调度的基本条件" class="headerlink" title="实现实时调度的基本条件"></a>实现实时调度的基本条件</h4><p>为了实现实时调度，系统应向调度程序提供以下信息：</p>
<ul>
<li><p>就绪时间</p>
</li>
<li><p>开始截止时间和完成截止时间</p>
</li>
<li><p>处理时间</p>
</li>
<li><p>资源要求</p>
</li>
<li><p>优先级</p>
</li>
<li><p>对于m个实时任务，处理时间为Ci，周期时间为Pi，如果满足下列条件，则系统是可调度的。</p>
</li>
</ul>
<img src="/images/操作系统/image-20221101111402160.png" alt="image-20221101111402160" style="zoom:50%;">

<p>注意：上述的限制条件未考虑到任务切换的时间。</p>
<h4 id="实时调度算法的分类"><a href="#实时调度算法的分类" class="headerlink" title="实时调度算法的分类"></a>实时调度算法的分类</h4><p>根据实时任务性质 </p>
<ul>
<li>​	硬实时调度算法：严格实时 </li>
<li>​	软实时调度算法：非严格实时</li>
</ul>
<p>根据调度方式 </p>
<ul>
<li>​	非抢占调度算法 </li>
<li>​	抢占调度算法</li>
</ul>
<p>根据调度时间 </p>
<ul>
<li>​	静态调度：在进程执行前，调度程序便已经决定了各进程间的执行顺序 </li>
<li>​	动态调度：在进程的执行过程中， 由调度程序届时根据情况临时决定将哪一进程投入运行</li>
</ul>
<p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221101112532357.png" alt="image-20221101112532357"></p>
<h4 id="最早截止时间优先EDF算法"><a href="#最早截止时间优先EDF算法" class="headerlink" title="最早截止时间优先EDF算法"></a>最早截止时间优先EDF算法</h4><p>EDF(Earliest Deadline First)算法是根据任务的开始截止时间来确定任务的优先级，截止时间愈早，其优先级愈高，设置实时任务就绪队列，按各任务截止时间的早晚排序，调度程序选择就绪队列中的第一个任务运行，即最需要开始的任务</p>
<h4 id="最低松弛度优先LLF算法"><a href="#最低松弛度优先LLF算法" class="headerlink" title="最低松弛度优先LLF算法"></a>最低松弛度优先LLF算法</h4><p>根据任务的紧急程度（松弛度）来确定任务的优先级。 </p>
<blockquote>
<p>松弛度 &#x3D; 必须完成时间&#x2F;完成截至时间 - 本身运行时间 - 当前时间 </p>
</blockquote>
<p>调度程序在选择任务时，总是选择就绪队列中(在任务执行周期)紧急程 度（松弛度最低）最大任务，为之分配处理机，使之投入运行。</p>
<h3 id="死锁概述"><a href="#死锁概述" class="headerlink" title="死锁概述"></a>死锁概述</h3><h2 id="3-存储器管理"><a href="#3-存储器管理" class="headerlink" title="3 存储器管理"></a>3 存储器管理</h2><h3 id="3-1-存储器的层次结构"><a href="#3-1-存储器的层次结构" class="headerlink" title="3.1 存储器的层次结构"></a>3.1 存储器的层次结构</h3><h3 id="3-2-程序的装入与链接"><a href="#3-2-程序的装入与链接" class="headerlink" title="3.2 程序的装入与链接"></a>3.2 程序的装入与链接</h3><p>用户程序要想在系统中运行，必须先将其装入内存，然后再将其转变为一个可以执行的程序，通常要经过以下几个步骤：</p>
<ol>
<li>编译：由编译程序（Compiler）对用户源程序进行编译，产生若干个目标模块。</li>
<li>链接：由链接程序（Linker）将编译后的形成的一组目标模块以及它们所需要的库函数链接在一起，形成一个完整的装入模块。</li>
<li>装入：由装入程序（Loader）将装入模块装入内存。</li>
</ol>
<h4 id="3-2-1-程序的装入"><a href="#3-2-1-程序的装入" class="headerlink" title="3.2.1 程序的装入"></a>3.2.1 程序的装入</h4><p><strong>1.绝对装入方式</strong></p>
<p>当计算机系统很小，且仅能运行单道程序时，此时可以采用绝对装入方式，用户程序编译后将产生绝对地址（物理地址）的目标代码。程序中所使用的绝对地址既可在编译或汇编时产生，也可以由程序员直接赋予。</p>
<p><strong>2.可重定位装入方式</strong></p>
<p>绝对装入方式只能将目标模块装入到内存指定的位置，这只适用于单道程序环境。在多道程序环境下，编译程序不可能知道编译后所得到的目标模块应该放到内存的何处，这时就应该采用<code>可重定位装入方式</code>，它可以根据内存的具体情况将装入模块装入到内存的适当位置。在装入时对目标程序中指令和数据地址的修改过程称为重定位，又因为地址变换是在进程装入时一次完成的，以后不再改变，因此也被称为<code>静态重定位</code>。</p>
<p><strong>3.动态运行时的装入方式</strong></p>
<p>动态运行的装入程序在把装入模块装入内存后，并不立即把装入模块的逻辑地址转换为物理地址，而是把这种转换推迟到程序真正要执行时才进行。这种方式允许程序运行时在内存中移动位置。</p>
<h4 id="3-2-2-程序的链接"><a href="#3-2-2-程序的链接" class="headerlink" title="3.2.2 程序的链接"></a>3.2.2 程序的链接</h4><p>源程序经过编译后，可得到一组目标模块。链接程序的功能是将这组目标模块以及其所需要的库函数装配成一个完整的装入模块。</p>
<p><strong>1.静态链接方式</strong></p>
<p>在程序运行之前，先将各目标模块与它们所需的库函数链接成一个完整的装配模块，以后不再拆开。</p>
<p><strong>2.装入时动态链接</strong></p>
<p>将用户源程序编译后得到的一组目标模块，在装入内存时，采用边装入边链接的链接方式。在装入一个目标模块时，如果发生一个外部模块调用事件，将引起装入程序去找出相应的外部目标模块并将其装入内存。</p>
<p><strong>3.运行时动态链接</strong></p>
<p>将对某些模块的链接推迟到程序执行时才执行。在执行过程中，当发现一个被调用模块尚未装入内存时，立即由OS去找到该模块，并将其装入内存，将其链接到调用者模块上。</p>
<h3 id="3-3-连续分配存储管理方式"><a href="#3-3-连续分配存储管理方式" class="headerlink" title="3.3 连续分配存储管理方式"></a>3.3 连续分配存储管理方式</h3><p>为了能将用户程序装入内存，需要为它分配一定大小的内存空间，连续分配方式是最早出现的一种存储器分配方式。</p>
<h4 id="3-3-1-单一连续分配"><a href="#3-3-1-单一连续分配" class="headerlink" title="3.3.1 单一连续分配"></a>3.3.1 单一连续分配</h4><p>在单道程序环境下，当时的存储器管理方式是把内存分为系统区和用户区两部分，系统区仅提供给OS使用。而在用户区内存中，仅装有一道用户程序，即整个内存的用户空间由该程序独占。</p>
<h4 id="3-3-2-固定分区分配"><a href="#3-3-2-固定分区分配" class="headerlink" title="3.3.2 固定分区分配"></a>3.3.2 固定分区分配</h4><p>将整个用户空间划分为若干个固定大小的区域，在每个分区中只装入一个作业，这样就形成了最早的，最简单的一个可运行多道程序的分区式存储管理方式。当有一个空闲分区时，可在后备作业队列中找出另一作业调入该分区。</p>
<blockquote>
<p>划分分区的方法</p>
<p>1.分区大小相等：该方法比较方便和实用，但缺乏灵活性，当程序太小时，会造成内存空间的浪费。当程序太大时，一个分区又不足以放入该程序。</p>
<p>2.分区大小不等：为了增加存储器分配的灵活性，应将存储器分区划分为若干个大小不等的分区，根据程序的大小动态的为之分配内存。</p>
</blockquote>
<p><strong>内存分配</strong></p>
<p>​	为了便于内存分配，通常将分区按其大小进行排队，并为之建立一张分区使用表，其中各表项包括各个分区的起始地址 ，大小及状态（是否已分配）。</p>
<p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221127164526048.png" alt="image-20221127164526048"></p>
<h4 id="3-3-3-动态分区分配"><a href="#3-3-3-动态分区分配" class="headerlink" title="3.3.3 动态分区分配"></a>3.3.3 动态分区分配</h4><p>​	动态分区分配又称可变分区分配，它是根据进程的实际需要，动态地为之分配内存空间。</p>
<p><strong>基本思想</strong></p>
<ul>
<li>OS初始化阶段，将用户区划分为一个大的空白分区</li>
<li>每个程序运行时，为其划分出一个大小合适的分区</li>
<li>程序执行结束，其所在的分区撤消</li>
</ul>
<h5 id="动态分区分配中的数据结构"><a href="#动态分区分配中的数据结构" class="headerlink" title="动态分区分配中的数据结构"></a><strong>动态分区分配中的数据结构</strong></h5><p>1.空闲分区表：用于记录每个空闲分区的情况。每个空闲分区占一个表目，表目中包括分区号，分区大小和分区始址等数据项</p>
<p>2.空闲分区链：为了实现对空闲分区的分配和链接，在每个分区的起始部分设置一些用于控制分区分配的信息，以及用于链接各分区所用的前向指针，在分区尾部则设置一后向指针。</p>
<p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221128093111360.png" alt="image-20221128093111360"></p>
<h5 id="分区分配操作"><a href="#分区分配操作" class="headerlink" title="分区分配操作"></a><strong>分区分配操作</strong></h5><p>在动态分区存储管理方式中，主要的操作是分配内存和回收内存。</p>
<p>1.分配内存（增加分区表表项）</p>
<p>系统利用某种分配算法，从空闲分区表中找到所需大小的分区，若将分区分割后剩余区域太小（小于设置的某个值），就将该分区整个交给请求者，否则便从该分区按请求的大小划分出一块内存空间分配出去，余下的部分留在空闲分区表（链）中，然后将分配区的首址返回给请求者并且修改有关数据结构。</p>
<p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221129115639060.png" alt="image-20221129115639060"></p>
<p>2.回收内存（可能减少分区表表项）</p>
<p>当进程运行完毕释放内存时，系统根据回收区的首址，从空闲区链(表)中找到相应的插入点，此时可能出现以下四种情况之一：</p>
<p>​	(1) 回收区与插入点的前一个空闲分区 F1 相邻接。此时应将回收区与插入点的前一分区合并，不必为回收分区分配新表项，而只需修改其前一分区 F1 的大小。<br>​	(2) 回收分区与插入点的后一空闲分区 F2 相邻接。此时也可将两分区合并，形成新的空闲分区，但用回收区的首址作为新空闲区的首址，大小为两者之和。<br>​	(3) 回收区同时与插入点的前、后两个分区邻接。此时将三个分区合并，使用 F1 的表项和 F1 的首址，取消 F2 的表项，大小为三者之和。<br>​	(4) 回收区既不与 F1 邻接，又不与 F2 邻接。这时应为回收区单独建立一新表项，填写回收区的首址和大小，并根据其首址插入到空闲链中的适当位置。</p>
<p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221129120051153.png" alt="image-20221129120051153"></p>
<h5 id="动态分区分配算法"><a href="#动态分区分配算法" class="headerlink" title="动态分区分配算法"></a><strong>动态分区分配算法</strong></h5><p>​	1.基于顺序搜索的动态分区分配算法</p>
<ul>
<li><p>首次适应算法（first fit）</p>
<p>我们以空闲分区链为例来说明采用 FF 算法时的分配情况。FF 算法要求空闲分区链以地址递增的次序链接。在分配内存时，从链首开始顺序查找，直至找到一个大小能满足要求的空闲分区为止；然后再按照作业的大小，从该分区中划出一块内存空间分配给请求者，余下的空闲分区仍留在空闲链中。若从链首直至链尾都不能找到一个能满足要求的分区，则此次内存分配失败，返回。该算法倾向于优先利用内存中低址部分的空闲分区，从而保留了高址部分的大空闲区。这给为以后到达的大作业分配大的内存空间创造了条件。其缺点是低址部分不断被划分，会留下许多难以利用的、很小的空闲分区，而每次查找又都是从低址部分开始，这无疑会增加查找可用空闲分区时的开销。</p>
</li>
<li><p>循环首次适应算法（next fit)</p>
<p>该算法是由首次适应算法演变而成的。在为进程分配内存空间时，不再是每次都从链首开始查找，而是从上次找到的空闲分区的下一个空闲分区开始查找，直至找到一个能满足要求的空闲分区，从中划出一块与请求大小相等的内存空间分配给作业。该算法能使内存中的空闲分区分布得更均匀，从而减少了查找空闲分区时的开销，但这样会缺乏大的空闲分区。</p>
</li>
<li><p>最佳适应算法（best fit)	</p>
<p>所谓“最佳”是指每次为作业分配内存时，总是把能满足要求、又是最小的空闲分区分配给作业，避免“大材小用”。为了加速寻找，该算法要求将所有的空闲分区按其容量以从小到大的顺序形成一空闲分区链。这样，第一次找到的能满足要求的空闲区，必然是最佳的。孤立地看，最佳适应算法似乎是最佳的，然而在宏观上却不一定。因为每次分配后所切割下来的剩余部分总是最小的，这样，在存储器中会留下许多难以利用的小空闲区。</p>
</li>
<li><p>最坏适应算法（worst fit）</p>
<p>最坏适应分配算法要扫描整个空闲分区表或链表，总是挑选一个最大的空闲区分割给作业使用，其优点是可使剩下的空闲区不至于太小，产生碎片的几率最小，对中、小作业有利，同时最坏适应分配算法查找效率很高。该算法要求将所有的空闲分区按其容量以从大到小的顺序形成一空闲分区链，查找时只要看第一个分区能否满足作业要求。但是该算法的缺点也是明显的，它会使存储器中缺乏大的空闲分区。</p>
</li>
</ul>
<p>2.基于索引搜索的动态分区分配算法</p>
<p>基于顺序搜索的动态分区分配算法，比较适用于不太大的系统。当系统很大时，其中的内存分区可能会很多，相应的空闲分区链可能很长，这时采用顺序搜索算法就会很慢。为了提高搜索速度，在大中型系统往往会采用基于索引搜索的动态分区搜索算法。</p>
<ul>
<li><p>快速适应算法（quick fit）<br>该算法又称为分类搜索法，是将空闲分区根据其容量大小进行分类，对于每一类具有相同容量的所有空闲分区，单独设立一个空闲分区链表，这样，系统中存在多个空闲分区链表，同时在内存中设立一张管理索引表，该表的每一个表项对应了一种空闲分区类型，并记录了该类型空闲分区链表表头的指针。空闲分区的分类是根据进程常用的空间大小进行划分，如 2 KB、4 KB、8 KB 等，对于其它大小的分区，如 7 KB 这样的空闲区，既可以放在 8 KB 的链表中，也可以放在一个特殊的空闲区链表中。</p>
<p>该算法的优点是查找效率高，仅需要根据进程的长度，寻找到能容纳它的最小空闲区链表，并取下第一块进行分配即可。另外该算法在进行空闲分区分配时，不会对任何分区产生分割，所以能保留大的分区，满足对大空间的需求，也不会产生内存碎片。<br>该算法的缺点是在分区归还主存时算法复杂，系统开销较大。此外，该算法在分配空闲分区时是以进程为单位，一个分区只属于一个进程，因此在为进程所分配的一个分区中，或多或少地存在一定的浪费。空闲分区划分越细，浪费则越严重，整体上会造成可观的存储空间浪费，这是典型的以空间换时间的作法。</p>
</li>
<li><p>伙伴系统（buddy system）</p>
</li>
</ul>
<p>​		</p>
<ul>
<li>哈希算法</li>
</ul>
<h5 id="动态可重定位分区分配"><a href="#动态可重定位分区分配" class="headerlink" title="动态可重定位分区分配"></a>动态可重定位分区分配</h5><p><strong>紧凑方法</strong></p>
<p>​	连续分配方式的一个重要特点是，一个系统或用户程序必须被装入一片连续的内存当中，当一台计算机运行了一段时间后，它的内存空间将会被分割成许多小的分区，这样内部就有许多无法被使用的小空闲区，也就是<code>“内存碎片”</code>，或称为<code>“零头”</code></p>
<p>​	为了获得更大的可使用的内存空间。可采用的一种方法是：将内存中所有的作业进行移动，使它们全部相邻接。</p>
<p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221130201708245.png" alt="image-20221130201708245"></p>
<p>​	在每次紧凑后，都必须对移动了的程序或数据进行地址重定位，这将大大影响系统的效率。动态重定位方式可以很好地解决这个问题。</p>
<blockquote>
<p>动态重定位</p>
<p>在动态运行时装入的方式中，作业装入内存后的所有地址都仍然是相对地址，将相对地址转换为物理地址的工作，被推迟到程序指令要真正执行时进行。为使地址的转换不会影响到指令的执行速度，必须有硬件地址变换机构的支持，即须在系统中增设一个重定位寄存器。真正访问的内存地址是相对地址与重定位寄存器中的地址相加而形成的。</p>
<p>下图示出了动态重定位的实现原理。地址变换过程是在程序执行期间，随着对每条指令或数据的访问自动进行的，故称为<code>动态重定位</code>。当系统对内存进行了“紧凑”而使若干程序从内存的某处移至另一处时，不需对程序做任何修改，只要用该程序在内存的新起始地址，去置换原来的起始地址即可。</p>
<p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221130204448081.png" alt="image-20221130204448081"></p>
</blockquote>
<p><strong>动态重定位分区分配算法</strong><br>动态重定位分区分配算法与动态分区分配算法基本上相同，差别仅在于：在这种分配算法中，增加了紧凑的功能，通常，在找不到足够大的空闲分区来满足用户需求时进行紧凑。</p>
<h3 id="3-4-对换"><a href="#3-4-对换" class="headerlink" title="3.4 对换"></a>3.4 对换</h3><p>所谓<code>对换</code>，是指把内存中暂时不能运行的进程或者暂时不用的程序和数据调出到外存上，以便腾出足够的内存空间，再把已具备运行条件的进程或进程所需要的程序和数据调入内存。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://h1song.github.io">hlsong</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://h1song.github.io/2022/11/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">http://h1song.github.io/2022/11/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://h1song.github.io" target="_blank">八千里云月</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://s1.ax1x.com/2022/11/30/zwgUpQ.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2022/11/26/hello-world/"><img class="next-cover" src="https://s1.ax1x.com/2022/11/30/zwgUpQ.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Hello World</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s1.ax1x.com/2022/11/30/zwgJk8.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">hlsong</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/h1song"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">记录学习之路</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.</span> <span class="toc-text">操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">1.1.</span> <span class="toc-text">1 进程管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8F%8F%E8%BF%B0"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1 进程的描述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-1-%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">1.1.1 进程的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-2-%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">1.1.2 进程的特征</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-3-%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81%E5%8F%8A%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">1.1.3 进程的基本状态及转换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81"><span class="toc-number">1.1.1.3.1.</span> <span class="toc-text">进程的三种基本状态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.1.1.3.2.</span> <span class="toc-text">三种基本状态的转换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%8A%B6%E6%80%81%E5%92%8C%E7%BB%88%E6%AD%A2%E7%8A%B6%E6%80%81"><span class="toc-number">1.1.1.3.3.</span> <span class="toc-text">创建状态和终止状态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%82%E8%B5%B7%E6%93%8D%E4%BD%9C%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.1.1.3.4.</span> <span class="toc-text">挂起操作和进程状态的转换</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8C%82%E8%B5%B7%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.1.3.4.1.</span> <span class="toc-text">挂起操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-4%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">1.1.4进程的控制结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF"><span class="toc-number">1.1.1.4.1.</span> <span class="toc-text">进程控制块中的信息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97%E7%9A%84%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F"><span class="toc-number">1.1.1.4.2.</span> <span class="toc-text">进程控制块的组织方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2 进程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">1.2.1 操作系统内核</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2-%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">1.2.2 进程的创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-3-%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%98%BB%E5%A1%9E%E4%B8%8E%E5%94%A4%E9%86%92"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">1.2.3 进程的阻塞与唤醒</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-4-%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-number">1.1.2.4.</span> <span class="toc-text">1.2.4 进程的上下文切换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.3 进程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">1.3.1 进程同步的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98%E7%9A%84%E4%BA%A7%E7%94%9F%EF%BC%9A"><span class="toc-number">1.1.3.1.1.</span> <span class="toc-text">进程同步问题的产生：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E5%BD%A2%E5%BC%8F%E7%9A%84%E5%88%B6%E7%BA%A6%E5%85%B3%E7%B3%BB%EF%BC%9A"><span class="toc-number">1.1.3.1.2.</span> <span class="toc-text">两种形式的制约关系：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%B4%E7%95%8C%E8%B5%84%E6%BA%90"><span class="toc-number">1.1.3.1.3.</span> <span class="toc-text">临界资源</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%B4%E7%95%8C%E5%8C%BA"><span class="toc-number">1.1.3.1.4.</span> <span class="toc-text">临界区</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E5%BA%94%E9%81%B5%E5%BE%AA%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-number">1.1.3.1.5.</span> <span class="toc-text">同步机制应遵循的规则</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-2-%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E6%97%A9%E6%9C%9F%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">1.3.2 实现进程同步的早期方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%A7%A3%E6%B3%95"><span class="toc-number">1.1.3.2.1.</span> <span class="toc-text">软件解法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E8%A7%A3%E6%B3%95"><span class="toc-number">1.1.3.2.2.</span> <span class="toc-text">硬件解法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%A9%E7%94%A8SWAP%E6%8C%87%E4%BB%A4%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5"><span class="toc-number">1.1.3.2.2.1.</span> <span class="toc-text">利用SWAP指令实现进程互斥</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6"><span class="toc-number">1.1.3.2.3.</span> <span class="toc-text">信号量机制</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">1.1.3.2.3.1.</span> <span class="toc-text">整数型信号量</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">1.1.3.2.3.2.</span> <span class="toc-text">记录型信号量</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.1.3.2.4.</span> <span class="toc-text">信号量的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%94%A8%E4%BA%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5"><span class="toc-number">1.1.3.2.4.1.</span> <span class="toc-text">信号量用于进程互斥</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%94%A8%E4%BA%8E%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">1.1.3.2.4.2.</span> <span class="toc-text">信号量用于进程同步</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%A1%E7%A8%8B%E6%9C%BA%E5%88%B6"><span class="toc-number">1.1.3.2.5.</span> <span class="toc-text">管程机制</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-3-%E7%BB%8F%E5%85%B8%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">1.3.3 经典进程同步问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E2%80%94%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.3.3.1.</span> <span class="toc-text">生产者—消费者问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.3.3.2.</span> <span class="toc-text">哲学家进餐问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.3.3.3.</span> <span class="toc-text">读者-写者问题</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%AF%BB%E8%80%85%E4%BC%98%E5%85%88"><span class="toc-number">1.1.3.3.3.1.</span> <span class="toc-text">读者优先</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%86%99%E8%80%85%E4%BC%98%E5%85%88"><span class="toc-number">1.1.3.3.3.2.</span> <span class="toc-text">写者优先</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-number">1.1.4.</span> <span class="toc-text">1.4 进程通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-1-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">1.4.1 进程通信的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%A1%E9%81%93"><span class="toc-number">1.1.4.1.1.</span> <span class="toc-text">管道</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E5%88%9B%E5%BB%BA%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.4.1.1.1.</span> <span class="toc-text">管道创建的原理</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">1.1.4.1.2.</span> <span class="toc-text">消息队列</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="toc-number">1.1.4.1.3.</span> <span class="toc-text">共享内存</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="toc-number">1.1.4.1.3.1.</span> <span class="toc-text">基本思想</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B"><span class="toc-number">1.1.4.1.3.2.</span> <span class="toc-text">实现过程</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7"><span class="toc-number">1.1.4.1.4.</span> <span class="toc-text">信号</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Socket"><span class="toc-number">1.1.4.1.5.</span> <span class="toc-text">Socket</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.1.5.</span> <span class="toc-text">1.5 线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-1-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%BC%95%E5%85%A5"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">1.5.1 线程的引入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-2-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.5.2.</span> <span class="toc-text">1.5.2 线程的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-3-%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">1.1.5.3.</span> <span class="toc-text">1.5.3 线程与进程的比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-4-%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-number">1.1.5.4.</span> <span class="toc-text">1.5.4 线程的上下文切换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-5-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.1.5.5.</span> <span class="toc-text">1.5.5 线程的实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E5%92%8C%E6%AD%BB%E9%94%81"><span class="toc-number">1.2.</span> <span class="toc-text">2 处理机调度和死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1 调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-%E8%BD%AE%E8%BD%AC%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">2.1.1 轮转模型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BD%A9%E7%A5%A8%E8%B0%83%E5%BA%A6%EF%BC%88%E5%AF%BC%E8%AE%BA65%EF%BC%89"><span class="toc-number">1.2.1.1.1.</span> <span class="toc-text">彩票调度（导论65）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A5%E9%95%BF%E8%B0%83%E5%BA%A6%EF%BC%88%E5%AF%BC%E8%AE%BA69%EF%BC%89"><span class="toc-number">1.2.1.1.2.</span> <span class="toc-text">步长调度（导论69）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-%E9%98%9F%E5%88%97%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">2.1.2 队列模型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%8D%E5%90%8E%E5%8F%B0%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6"><span class="toc-number">1.2.1.2.1.</span> <span class="toc-text">前后台队列调度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6"><span class="toc-number">1.2.1.2.2.</span> <span class="toc-text">多级反馈队列调度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2 实时调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">实现实时调度的基本条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">实时调度算法的分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E6%97%A9%E6%88%AA%E6%AD%A2%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88EDF%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">最早截止时间优先EDF算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E4%BD%8E%E6%9D%BE%E5%BC%9B%E5%BA%A6%E4%BC%98%E5%85%88LLF%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">最低松弛度优先LLF算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E6%A6%82%E8%BF%B0"><span class="toc-number">1.2.3.</span> <span class="toc-text">死锁概述</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86"><span class="toc-number">1.3.</span> <span class="toc-text">3 存储器管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.1 存储器的层次结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%A3%85%E5%85%A5%E4%B8%8E%E9%93%BE%E6%8E%A5"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.2 程序的装入与链接</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%A3%85%E5%85%A5"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">3.2.1 程序的装入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%93%BE%E6%8E%A5"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">3.2.2 程序的链接</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.3 连续分配存储管理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-%E5%8D%95%E4%B8%80%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">3.3.1 单一连续分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">3.3.2 固定分区分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-3-%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">3.3.3 动态分区分配</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.3.3.1.</span> <span class="toc-text">动态分区分配中的数据结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E6%93%8D%E4%BD%9C"><span class="toc-number">1.3.3.3.2.</span> <span class="toc-text">分区分配操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number">1.3.3.3.3.</span> <span class="toc-text">动态分区分配算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D"><span class="toc-number">1.3.3.3.4.</span> <span class="toc-text">动态可重定位分区分配</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E5%AF%B9%E6%8D%A2"><span class="toc-number">1.3.4.</span> <span class="toc-text">3.4 对换</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/11/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="操作系统笔记"><img src="https://s1.ax1x.com/2022/11/30/zwgUpQ.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="操作系统笔记"/></a><div class="content"><a class="title" href="/2022/11/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="操作系统笔记">操作系统笔记</a><time datetime="2022-11-29T13:44:26.546Z" title="发表于 2022-11-29 21:44:26">2022-11-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/26/hello-world/" title="Hello World"><img src="https://s1.ax1x.com/2022/11/30/zwgUpQ.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hello World"/></a><div class="content"><a class="title" href="/2022/11/26/hello-world/" title="Hello World">Hello World</a><time datetime="2022-11-26T07:57:16.479Z" title="发表于 2022-11-26 15:57:16">2022-11-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By hlsong</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>